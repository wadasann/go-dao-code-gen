// This file was generated by go-dao-code-gen. 
// You can modify it to be more suitable. 

package {{ .Pkg }}

import (
	"context"
	"errors"
    "fmt"
    {{range .Imports}}
    "{{.}}"
    {{end}}
    
	"github.com/huandu/go-sqlbuilder"
)

const ( // {{ .TableLowerCamelIdent }}TableName specifies the table name.
    {{ .TableUpperCamelIdent }}TableName = "{{ .Table }}"
    // Max{{ .TableUpperCamelIdent }}Limit specifies the limit of insert and select operations.
	Max{{ .TableUpperCamelIdent }}Limit int = 1000
)

var (
	{{ .TableLowerCamelIdent }}Alias        {{ .TableUpperCamelIdent }}Alias
	{{ .TableLowerCamelIdent }}Fields       []string
)

// {{ .TableUpperCamelIdent }}Dao specifies the DAO object.
type {{ .TableUpperCamelIdent }}Dao struct {
	db          *sql.DB
    forceMaster bool
    *{{ .TableUpperCamelIdent }}Alias
}

// {{ .TableUpperCamelIdent }}Alias represents the alias of fields in table {{ .Table }}. 
type {{ .TableUpperCamelIdent }}Alias struct {
{{- range .Attrs }}
        {{ .Name }} string // {{ .Tag }}
{{- end }}
}

// {{ .TableUpperCamelIdent }}Entity represents the {{ .Table }} table mapping. 
// Please manually remove the update tag from fields that are not allowed to be modified.
type {{ .TableUpperCamelIdent }}Entity struct {
{{- range .Attrs }}
        {{ .Name }} {{ .Type }} `db:"{{ .Tag }}"` {{ if .Comment -}}// {{ .Comment }} {{- end }} 
{{- end }}
}

func init() {
    InitTableAlias({{ .TableUpperCamelIdent }}Entity{}, &{{ .TableLowerCamelIdent }}Alias)
	InitTableFields({{ .TableUpperCamelIdent }}Entity{}, &{{ .TableLowerCamelIdent }}Fields)
}

// New{{ .TableUpperCamelIdent }}Dao creates a new table object.
func New{{ .TableUpperCamelIdent }}Dao() *{{ .TableUpperCamelIdent }}Dao {
	return &{{ .TableUpperCamelIdent }}Dao{
		db: globalDB,
        {{ .TableUpperCamelIdent }}Alias: &{{ .TableLowerCamelIdent }}Alias,
	}
}

// Insert inserts one data record.
func (d *{{ .TableUpperCamelIdent }}Dao) Insert(ctx context.Context, values map[string]any)(lastInsertID int64, err error){
    if len(values) == 0 {
        return lastInsertID, errors.New("param values cannot be empty")
    }
    cols := make([]string, 0, len(values))
    vals := make([]any, 0, len(values))
    for _, field := range {{ .TableLowerCamelIdent }}Fields {
        if val, ok := values[field]; ok {
            cols = append(cols, field)
            vals = append(vals, val)
        } 
    }
    if len(cols) == 0 {
        return lastInsertID, errors.New("no valid field data found")
    }
    {{- if or (ne .TimeFields.CreateTime "") (ne .TimeFields.UpdateTime "")}}
    curTime := time.Now()
    {{- end }}
    {{- if ne .TimeFields.CreateTime ""}}
    if _, ok := values["{{.TimeFields.CreateTime}}"]; !ok {
        cols = append(cols, "{{.TimeFields.CreateTime}}")
        {{- if eq .TimeFields.CreateType "int" }}
        vals = append(vals, curTime.Unix())
        {{- else }}
        vals = append(vals, curTime)
        {{- end }}
    }
    {{- end }}
    {{- if ne .TimeFields.UpdateTime ""}}
    if _, ok := values["{{.TimeFields.UpdateTime}}"]; !ok {
        cols = append(cols, "{{.TimeFields.UpdateTime}}")
        {{- if eq .TimeFields.UpdateType "int" }}
        vals = append(vals, curTime.Unix())
        {{- else }}
        vals = append(vals, curTime)
        {{- end }}
    }
    {{- end }}
    ib := sqlbuilder.NewInsertBuilder()
    ib.InsertInto({{ .TableUpperCamelIdent }}TableName)
    ib.Cols(cols...)
    ib.Values(vals...)
    sql, args := ib.Build()
	result, err := d.db.Exec(sql,args...)
	if err != nil{
        // TODO: log error
		return lastInsertID,err 
	}
	return result.LastInsertId()
}

// InsertMany inserts multiple data records.
func (d *{{ .TableUpperCamelIdent }}Dao) InsertMany(ctx context.Context, valueList []map[string]any) (err error) {
	if len(valueList) == 0 {
		return
	}
    if len(valueList) > Max{{ .TableUpperCamelIdent }}Limit {
        return fmt.Errorf("received %d data, exceeding the maximum %d limit", len(valueList), Max{{ .TableUpperCamelIdent }}Limit)
    }
	var cols []string
	var valsList [][]any
	for index, values := range valueList {
		if len(values) == 0 {
			return errors.New("param values cannot be empty")
		}
		vals := make([]any, 0, len(values))
		for _, field := range {{ .TableLowerCamelIdent }}Fields {
			if val, ok := values[field]; ok {
				if index == 0 {
					cols = append(cols, field)
				}
				vals = append(vals, val)
			}
		}
		valsList = append(valsList, vals)
	}
	if len(cols) == 0 {
		return errors.New("no valid field data found")
	}
    {{- if ne .TimeFields.CreateTime ""}}
    var hasAddCreate bool
    if _, ok := valueList[0]["{{.TimeFields.CreateTime}}"]; !ok {
        cols = append(cols, "{{.TimeFields.CreateTime}}")
        hasAddCreate = true
    }
    {{- end }}
    {{- if ne .TimeFields.UpdateTime ""}}
    var hasAddUpdate bool
    if _, ok := valueList[0]["{{.TimeFields.UpdateTime}}"]; !ok {
        cols = append(cols, "{{.TimeFields.UpdateTime}}")
        hasAddUpdate = true
    }
    {{- end }}
	ib := sqlbuilder.NewInsertBuilder()
	ib.InsertInto({{ .TableUpperCamelIdent }}TableName)
	ib.Cols(cols...)
    {{- if or (ne .TimeFields.CreateTime "")  (ne .TimeFields.UpdateTime "")}}
	curTime := time.Now()
    {{- end }}
	for _, vals := range valsList {
        {{- if ne .TimeFields.CreateTime ""}}
        if hasAddCreate {
            {{- if eq .TimeFields.CreateType "int" }}
            vals = append(vals, curTime.Unix())
            {{- else }}
            vals = append(vals, curTime)
            {{- end }}
        }
        {{- end }}
        {{- if ne .TimeFields.UpdateTime ""}}
        if hasAddUpdate {
            {{- if eq .TimeFields.UpdateType "int" }}
            vals = append(vals, curTime.Unix())
            {{- else }}
            vals = append(vals, curTime)
            {{- end }}
        }
        {{- end }}
		ib.Values(vals...)
	}
	sql, args := ib.Build()
	_, err = d.db.Exec(sql, args...)
	if err != nil {
		return err
	}
	return nil
}


// Get retrieves one data record that meets the query criteria.
func (d *{{ .TableUpperCamelIdent }}Dao) Get(ctx context.Context, conds ...{{ .TableUpperCamelIdent }}Cond) ({{ .TableLowerCamelIdent }}Entity *{{ .TableUpperCamelIdent }}Entity, err error) {
	sb := sqlbuilder.NewSelectBuilder()
	sb.Select({{ .TableLowerCamelIdent }}Fields...)
	sb.From({{ .TableUpperCamelIdent }}TableName)
	o := New{{ .TableUpperCamelIdent }}Conds(conds...)
	sqlArgs := Build{{ .TableUpperCamelIdent }}Conds(&sb.Cond, &o)
	sb.Where(sqlArgs...)
    sb.OrderBy("{{.Primary}}").Desc()
	sb.Limit(1)
	sql, args := sb.Build()
    if d.forceMaster {
        sql = ForceMasterIdentity + sql
    }
	rows, err := d.db.Query(sql, args...)
	if err != nil {
		return
	}
	defer rows.Close()
	if rows.Next() {
		{{ .TableLowerCamelIdent }}Entity = &{{ .TableUpperCamelIdent }}Entity{}
		{{ .TableLowerCamelIdent }}Struct := sqlbuilder.NewStruct(new({{ .TableUpperCamelIdent }}Entity))
		err = rows.Scan({{ .TableLowerCamelIdent }}Struct.Addr({{ .TableLowerCamelIdent }}Entity)...)
        if err != nil {
            return 
        }
	}
	return
}

// Count returns the total number of data records that meet the query criteria.
func (d *{{ .TableUpperCamelIdent }}Dao) Count(ctx context.Context, conds ...{{ .TableUpperCamelIdent }}Cond) (total int, err error) {
	sb := sqlbuilder.NewSelectBuilder()
	sb.Select("count(*)")
	sb.From({{ .TableUpperCamelIdent }}TableName)
	o := New{{ .TableUpperCamelIdent }}Conds(conds...)
	sqlArgs := Build{{ .TableUpperCamelIdent }}Conds(&sb.Cond, &o)
	sb.Where(sqlArgs...)
	sql, args := sb.Build()
    if d.forceMaster {
        sql = ForceMasterIdentity + sql
    }
	rows, err := d.db.Query(sql, args...)
	if err != nil {
        // TODO: log error
		return
	}
	defer rows.Close()
	if rows.Next() {
		err = rows.Scan(&total)
        if err != nil {
            return 
        }
	}
	return
}

// List retrieves multiple data records that meet the query criteria.
func (d *{{ .TableUpperCamelIdent }}Dao) List(ctx context.Context, limit, offset int, conds ...{{ .TableUpperCamelIdent }}Cond) ({{ .TableLowerCamelIdent }}List []*{{ .TableUpperCamelIdent }}Entity, err error) {
	sb := sqlbuilder.NewSelectBuilder()
	sb.Select({{ .TableLowerCamelIdent }}Fields...)
	sb.From({{ .TableUpperCamelIdent }}TableName)
	o := New{{ .TableUpperCamelIdent }}Conds(conds...)
	sqlArgs := Build{{ .TableUpperCamelIdent }}Conds(&sb.Cond, &o)
	sb.Where(sqlArgs...)
    sb.OrderBy("{{.Primary}}").Desc()
    if limit <= 0 || limit > Max{{ .TableUpperCamelIdent }}Limit {
    	sb.Limit(Max{{ .TableUpperCamelIdent }}Limit)
    } else {
    	sb.Limit(limit)
    }
    if offset >= 0 {
    	sb.Offset(offset)
    }
	sql, args := sb.Build()
    if d.forceMaster {
        sql = ForceMasterIdentity + sql
    }
	rows, err := d.db.Query(sql, args...)
	if err != nil {
        // TODO: log error
		return
	}
	defer rows.Close()
	{{ .TableLowerCamelIdent }}Struct := sqlbuilder.NewStruct(new({{ .TableUpperCamelIdent }}Entity))
	for rows.Next() {
		{{ .TableLowerCamelIdent }}Entity := &{{ .TableUpperCamelIdent }}Entity{}
		err = rows.Scan({{ .TableLowerCamelIdent }}Struct.Addr({{ .TableLowerCamelIdent }}Entity)...)
        if err != nil {
            return 
        }
		{{ .TableLowerCamelIdent }}List = append({{ .TableLowerCamelIdent }}List, {{ .TableLowerCamelIdent }}Entity)
	}
	return
}

// All retrieves all data records that meet the query criteria.
func (d *{{ .TableUpperCamelIdent }}Dao) All(ctx context.Context, limit int, conds ...{{ .TableUpperCamelIdent }}Cond) ({{ .TableLowerCamelIdent }}List []*{{ .TableUpperCamelIdent }}Entity, err error) {
	sb := sqlbuilder.NewSelectBuilder()
	sb.Select({{ .TableLowerCamelIdent }}Fields...)
	sb.From({{ .TableUpperCamelIdent }}TableName)
	o := New{{ .TableUpperCamelIdent }}Conds(conds...)
	sqlArgs := Build{{ .TableUpperCamelIdent }}Conds(&sb.Cond, &o)
	sb.Where(sqlArgs...)
    sb.OrderBy("{{.Primary}}").Desc()
    if limit > 0 {
    	sb.Limit(limit)
    }
	sql, args := sb.Build()
    if d.forceMaster {
        sql = ForceMasterIdentity + sql
    }
	rows, err := d.db.Query(sql, args...)
	if err != nil {
        // TODO: log error
		return
	}
	defer rows.Close()
	{{ .TableLowerCamelIdent }}Struct := sqlbuilder.NewStruct(new({{ .TableUpperCamelIdent }}Entity))
	for rows.Next() {
		{{ .TableLowerCamelIdent }}Entity := &{{ .TableUpperCamelIdent }}Entity{}
		err = rows.Scan({{ .TableLowerCamelIdent }}Struct.Addr({{ .TableLowerCamelIdent }}Entity)...)
        if err != nil {
            return 
        }
		{{ .TableLowerCamelIdent }}List = append({{ .TableLowerCamelIdent }}List, {{ .TableLowerCamelIdent }}Entity)
	}
	return
}

// Update modifies the records that meet the query criteria.
func (d *{{ .TableUpperCamelIdent }}Dao) Update(ctx context.Context, values map[string]any, conds ...{{ .TableUpperCamelIdent }}Cond) (total int64, err error) {
	if len(conds) == 0 {
		return
	}
	ub := sqlbuilder.NewUpdateBuilder()
	ub.Update({{ .TableUpperCamelIdent }}TableName)
	fieldList := make([]string, 0, len(values))
	for index, val := range values {
		fieldList = append(fieldList, ub.Assign(index, val))
	}
	values = nil
	if len(fieldList) == 0 {
		return
	}
    {{- if ne .TimeFields.UpdateTime ""}}
        {{- if eq .TimeFields.UpdateType "int" }}
            fieldList = append(fieldList, ub.Assign("{{.TimeFields.UpdateTime}}", time.Now().Unix()))
        {{- else }}
            fieldList = append(fieldList, ub.Assign("{{.TimeFields.UpdateTime}}", time.Now()))
        {{- end }}
    {{- end }}
	ub.Set(fieldList...)
	o := New{{ .TableUpperCamelIdent }}Conds(conds...)
	sqlArgs := Build{{ .TableUpperCamelIdent }}Conds(&ub.Cond, &o)
	ub.Where(sqlArgs...)
	sql, args := ub.Build()
	result, err := d.db.Exec(sql, args...)
	if err != nil {
        // TODO: log error
		return
	}
	return result.RowsAffected()
}

// Delete removes the records that meet the query criteria.
func (d *{{ .TableUpperCamelIdent }}Dao) Delete(ctx context.Context, conds ...{{ .TableUpperCamelIdent }}Cond) (total int64, err error) {
	if len(conds) == 0 {
		return
	}
	db := sqlbuilder.NewDeleteBuilder()
	db.DeleteFrom({{ .TableUpperCamelIdent }}TableName)
	o := New{{ .TableUpperCamelIdent }}Conds(conds...)
	sqlArgs := Build{{ .TableUpperCamelIdent }}Conds(&db.Cond, &o)
	db.Where(sqlArgs...)
	sql, args := db.Build()
	result, err := d.db.Exec(sql, args...)
	if err != nil {
        // TODO: log error
		return
	}
	return result.RowsAffected()
}

// Query executes a custom query and returns the records that meet the criteria.
func (d *{{ .TableUpperCamelIdent }}Dao) Query(query string, args ...any) (*sql.Rows, error) {
    if d.forceMaster {
        query = ForceMasterIdentity + query
    }
    return d.db.Query(query, args...)
}

// Exec executes a custom SQL statement.
func (d *{{ .TableUpperCamelIdent }}Dao) Exec(query string, args ...any) (sql.Result, error) {
    if d.forceMaster {
        query = ForceMasterIdentity + query
    }
    return d.db.Exec(query, args...)
}


// ForceMaster adds the master identity for operations of the current object. 
func (d *{{ .TableUpperCamelIdent }}Dao) ForceMaster(){
    d.forceMaster = true
}

// DisableForceMaster removes the master identity for operations of the current object. 
func (d *{{ .TableUpperCamelIdent }}Dao) DisableForceMaster(){
    d.forceMaster = false
}

func (d *{{ .TableUpperCamelIdent }}Dao) UseConn(db *sql.DB){
    d.db = db
}

func (d *{{ .TableUpperCamelIdent }}Dao) CloneConn() (db *sql.DB) {
    return d.db
}
